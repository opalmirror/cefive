000000000011111111112222222222333333333344444444445555555555666666666
012345678901234567890123456789012345678901234567890123456789012345678
---------------------------------------------------------------------
0x08800000 00000000 00000000 00000000 00000000 ................
0x08800000  00000000 00000000 00000000 00000000      ................
0x08800000  00   00   00   00   00   00   00   00    .......         

000000000011111111112222222222333333333344444444445555555555666666666
012345678901234567890123456789012345678901234567890123456789012345678
---------------------------------------------------------------------
0x08800000 0x27BDFFF0   addiu    $sp, $sp, 0xFFF0

Allegrex Ops
0x70000024 mfic
0x70000026 mtic

[------][-----][-----][-----][-----][------]
rs rt rd
0111 0000 0000 0000 0000 0000 0010 0100
011100 00000 00000 00000 00000 100100

mfic rt, rd
mtic rt, rd

46807BE0
0100 0110 1000 0000 0111 1011 1110 0000
[0100 01][10 100][0 0000][0111 1][011 11][10 0000]
0x11     0x14    0       0x0F    0x0F    0x20

000000000011111111112222222222333333333344444444445555555555666666666
012345678901234567890123456789012345678901234567890123456789012345678
---------------------------------------------------------------------
CEFive 0.0                                        All Cheats Off
Search Panel

 Search Type: Byte Sequence
 Search Size: Dword
 Query: 0x08D8EA58

Search Results
Address  Value
0x08E7F700 0x08D8EA58

Status: Searching... 34%

[------|--][---|-----|][

Missing:
0x6C038007 01-10 11|00 0000 0011 1000 0000 0000 0111
0x1B|0|
0xD0008141 11-01 00|00 0|000 00|00 1000 0001 0100 0001
0x34 0x0 0x0
           00 00 00 00 000 0 0000  0000 0 111 11 00 0000
0x7C085D20 01-11 11|00 000|0 1000| 0101 1|101 00|10 0000
0x1F 0x0 0x08 0x0B 0x14 0x20

Junk from crt0_prx.c

void cheatSave() {
    unsigned char fileChar = 0;
    unsigned char fileMisc[3];
    unsigned int fileSize = 0;
    unsigned int counter = -1;
    unsigned int scounter = 0;
    //0=Unknown/Initial, 1=Comment, 2=Waiting for \n (ignoring)
    unsigned char fileMode = 0; 
    int fd;
    int tempFd;

    //1) Open the original cheat file
    fd = sceIoOpen(gameDir, PSP_O_RDONLY, 0777);
    if (fd > 0) {
        //Find the file size
        fileSize = sceIoLseek(fd, 0, SEEK_END);
        sceIoLseek(fd, 0, SEEK_SET);

        //Initiate the read buffer
        fileBufferOffset = 1024;
        fileBufferFileOffset = 0;

        //2) Open up the temporary and get ready to regenerate it
        tempFd = sceIoOpen("ms0:/seplugins/nitePR/temp.txt", PSP_O_WRONLY
                | PSP_O_CREAT, 0777);
        if (tempFd <= 0) {
            sceIoClose(fd);
            return;
        }

        //Add the codes that are already there
        while (fileBufferFileOffset < fileSize) {
            //Read a byte
            fileBufferRead(&fileChar, 1);
            if (fileBufferSize == 0)
                break;

            //Interpret the byte based on the mode
            if (fileMode == 0) {
                //Pick a mode
                switch (fileChar) {
                case ';':
                    fileMode = 1;
                    sceIoWrite(tempFd, ";", 1);
                    break;

                case '#':
                    fileMode = 2;
                    counter++;
                    //Add a double line skip?
                    if (counter != 0) {
                        sceIoWrite(tempFd, "\r\n", 2);
                    }

                    //Is there an error...?
                    if (counter >= cheatTotal) {
                        sceIoClose(tempFd);
                        sceIoClose(fd);
                        return;
                    }

                    //Set up the subCounter
                    scounter = cheat[counter].block;

                    //Is it on by default...?
                    if (cheat[counter].flags & CHEAT_FLAG_CONSTANT) {
                        sceIoWrite(tempFd, "#!!", 3);
                    } else if (cheat[counter].flags & CHEAT_FLAG_SELECTED) {
                        sceIoWrite(tempFd, "#!", 2);
                    } else {
                        sceIoWrite(tempFd, "#", 1);
                    }
                    //Write out the name of the cheat
                    sceIoWrite(tempFd, &cheat[counter].name, strlen(
                            cheat[counter].name));
                    sceIoWrite(tempFd, "\r\n", 2);
                    break;

                case '0':
                    if ((fileBufferFileOffset) < fileSize) {
                        fileBufferPeek(fileMisc[0], 0);
                        if (fileMisc[0] == 'x') {
                            //Is there an error...?
                            if (counter == (unsigned int) -1) {
                                sceIoClose(tempFd);
                                sceIoClose(fd);
                                return;
                            }
                            if (scounter >= (cheat[counter].block
                                    + cheat[counter].len)) {
                                sceIoClose(tempFd);
                                sceIoClose(fd);
                                return;
                            }

                            //Write out the address
                            if (block[scounter].flags & BLOCK_FLAG_DMA) {
                                sprintf(buffer, "0x%08lX ",
                                        (block[scounter].address));
                                sceIoWrite(tempFd, buffer, strlen(buffer));
                            } else {
                                sprintf(buffer, "0x%08lX ",
                                        (block[scounter].address - 0x08800000));
                                sceIoWrite(tempFd, buffer, strlen(buffer));
                            }

                            //Write out the value
                            if (block[scounter].flags & BLOCK_FLAG_FREEZE) {
                                switch (block[scounter].flags & BLOCK_FLAG_DWORD) {
                                case BLOCK_FLAG_DWORD:
                                    sprintf(buffer, "0x________\r\n");
                                    break;

                                case BLOCK_FLAG_WORD:
                                    sprintf(buffer, "0x____\r\n");
                                    break;

                                case BLOCK_FLAG_BYTE:
                                    sprintf(buffer, "0x__\r\n");
                                    break;
                                }
                            } else {
                                switch (block[scounter].flags & BLOCK_FLAG_DWORD) {
                                case BLOCK_FLAG_DWORD:
                                    sprintf(buffer, "0x%08lX\r\n",
                                            block[scounter].hakVal);
                                    break;

                                case BLOCK_FLAG_WORD:
                                    sprintf(
                                            buffer,
                                            "0x%04hX\r\n",
                                            (unsigned short) block[scounter].hakVal);
                                    break;

                                case BLOCK_FLAG_BYTE:
                                    sprintf(
                                            buffer,
                                            "0x%02hX\r\n",
                                            (unsigned char) block[scounter].hakVal);
                                    break;
                                }
                            }
                            sceIoWrite(tempFd, buffer, strlen(buffer));

                            //Skip the rest
                            fileMode = 2;
                            scounter++;
                        }
                    }
                    break;
                }
            } else if (fileMode == 1) {
                //Just copy it out straight to the file
                if ((fileChar == '\r') || (fileChar == '\n')) {
                    sceIoWrite(tempFd, "\r\n", 2);
                    fileMode = 0;
                } else {
                    sceIoWrite(tempFd, &fileChar, 1);
                }
            } else if (fileMode == 2) {
                //Just wait for an '\r' or '\n'
                if ((fileChar == '\r') || (fileChar == '\n')) {
                    fileMode = 0;
                }
            }
        }

        //Close the files
        sceIoClose(tempFd);
        sceIoClose(fd);

        //Delete the old file, rename the temporary
        sceIoRemove(gameDir);
        sceIoRename("ms0:/seplugins/nitePR/temp.txt", gameDir);
    }

    //Open the file for appending
    fd = sceIoOpen(gameDir, PSP_O_CREAT | PSP_O_WRONLY | PSP_O_APPEND, 0777);
    if (fd > 0) {
        //Add any new codes
        counter++;
        if (counter != 0)
            sceIoWrite(fd, "\r\n", 2);
        while (counter < cheatTotal) {
            //Write the cheat name
            if (cheat[counter].flags & CHEAT_FLAG_CONSTANT) {
                sceIoWrite(fd, "#!!", 3);
            } else if (cheat[counter].flags & CHEAT_FLAG_SELECTED) {
                sceIoWrite(fd, "#!", 2);
            } else {
                sceIoWrite(fd, "#", 1);
            }

            //Write out the name of the cheat
            sceIoWrite(fd, &cheat[counter].name, strlen(cheat[counter].name));
            sceIoWrite(fd, "\r\n", 2);

            //Loop through the addresses
            scounter = cheat[counter].block;
            while (scounter < (cheat[counter].block + cheat[counter].len)) {
                //Write out the address
                sprintf(buffer, "0x%08lX ", (block[scounter].address
                        - 0x08800000));
                sceIoWrite(fd, buffer, strlen(buffer));

                //Write out the value
                switch (block[scounter].flags & BLOCK_FLAG_DWORD) {
                case BLOCK_FLAG_DWORD:
                    sprintf(buffer, "0x%08lX\r\n", block[scounter].hakVal);
                    break;

                case BLOCK_FLAG_WORD:
                    sprintf(buffer, "0x%04hX\r\n",
                            (unsigned short) block[scounter].hakVal);
                    break;

                case BLOCK_FLAG_BYTE:
                    sprintf(buffer, "0x%02hX\r\n",
                            (unsigned char) block[scounter].hakVal);
                    break;
                }
                sceIoWrite(fd, buffer, strlen(buffer));

                //Next address
                scounter++;
            }

            //Next cheat
            counter++;
            sceIoWrite(fd, "\r\n", 2);
        }

        //Close the file
        sceIoClose(fd);
    }
}

static void computeCheats() {
    unsigned int counter;
    unsigned int scounter;
    unsigned int address;
    Cheat* prCheat = NULL;
    Block* prBlock = NULL;

    //Backup all the cheat "blocks"
    if (!cheatSaved) {
        counter = 0;
        scounter = 0;
        while (counter < blockTotal) {
            prCheat = &cheat[scounter];
            prBlock = &block[counter];
            if (prCheat->block == counter) {
                cheatDMA = 0; //Reset DNA on every new cheat
                scounter++;
            }

            // This part appears to recompute the DMA of all DMA cheats
            // and re-record the stdVal of every cheat.
            if (prBlock->flags & BLOCK_FLAG_DMA) {
                if (prBlock->hakVal != 0xFFFFFFFF) {
                    cheatDMA = *((unsigned int*) (0x08800000
                            + (prBlock->hakVal & 0x1FFFFFF)))
                            - 0x08800000;

                    if (((cheatDMA >= 0x00004000)
                            && (cheatDMA < 0x01800000)) || ((cheatDMA
                            >= 0x40004000) && (cheatDMA < 0x41800000))) {
                        prBlock->stdVal = cheatDMA;
                    }
                } else {
                    cheatDMA = 0;
                }
            } else {
                address = cheatDMA + prBlock->address;

                if (((address >= 0x08804000) && (address < 0x0A000000))
                        || ((address >= 0x48804000) && (address
                                < 0x4A000000))) {
                    switch (prBlock->flags & BLOCK_FLAG_DWORD) {
                    case BLOCK_FLAG_DWORD:
                        if (address % 4 == 0) {
                            prBlock->stdVal = *((unsigned int*) (address));
                        }
                        break;
                    case BLOCK_FLAG_WORD:
                        if (address % 2 == 0) {
                            prBlock->stdVal = *((unsigned short*) (address));
                        }
                        break;
                    case BLOCK_FLAG_BYTE:
                        prBlock->stdVal = *((unsigned char*) (address));
                        break;
                    }
                }
            }
            counter++;
        }
    }
}

static void findScreenshotDirectory() {
    signed int fd;

    //Find which screen directory to use
    fd = sceIoDopen("ms0:/PICTURE/");
    if (fd > 0) {
        sceIoDclose(fd);

        strcpy(screenPath, "ms0:/PICTURE/screen%d.bmp");
    } else {
        fd = sceIoDopen("ms0:/PSP/PHOTO/");
        if (fd > 0) {
            sceIoDclose(fd);

            strcpy(screenPath, "ms0:/PSP/PHOTO/screen%d.bmp");
        } else {
            if (!sceIoMkdir("ms0:/PICTURE", 0777)) {
                strcpy(screenPath, "ms0:/PICTURE/screen%d.bmp");
            } else {
                screenPath[0] = 0;
            }
        }
    }
}

static void findCorrectScreenNumber() {
    signed int fd;
    //Set the correct screen number
    screenNo = 0;
    if (screenPath[0] != 0) {
        while (1) {
            sprintf(buffer, screenPath, screenNo);
            fd = sceIoOpen(buffer, PSP_O_RDONLY, 0777);
            if (fd > 0) {
                sceIoClose(fd);
                screenNo++;
            } else {
                break;
            }
        }
    }
}

static void applyOpenPSIDPatch() {
    signed int fd;
    int skip = 0;
    //OpenPSID
    //if(cfg[19])
    {
        //Generate the patch
        *((unsigned short*) (&patchA[0]))
                = (unsigned short) (((unsigned int) sceOpenPSIDGetOpenPSID)
                        >> 16);
        *((unsigned short*) (&patchA[4]))
                = (unsigned short) ((unsigned int) &sceOpenPSIDGetOpenPSID);

        //Find the function we want!
        while (1) {
            int mod = sceKernelFindModuleByName(hookB[0].modname);
            if (mod == NULL) {
                sceKernelDelayThread(100);
                continue;
            }
            break;
        }
        unsigned int hookAddress = moduleFindFunc(
                moduleFindLibrary(
                        sceKernelSearchModuleByName(hookB[0].modname),
                        hookB[0].libname), hookB[0].nid);
        hookAddress = *((unsigned int*) hookAddress);

        //Open the PSID file
        fd = sceIoOpen("ms0:/seplugins/nitePR/nitePRimportant.bin",
                PSP_O_RDONLY, 0777);
        if (fd > 0) {
            sceIoRead(fd, psid, 16);
            sceIoClose(fd);
        } else {
            fd = sceIoOpen("ms0:/seplugins/nitePR/nitePRimportant.bin",
                    PSP_O_WRONLY | PSP_O_CREAT, 0777);
            if (fd > 0) {
                ((int(*)(char*)) hookAddress)(psid);
                sceIoWrite(fd, psid, 16);
                sceIoClose(fd);
            } else {
                skip = 1;
            }
        }

        if (skip == 0) {
            //Apply the memcpy
            sceKernelDcacheWritebackAll();
            sceKernelIcacheInvalidateAll();

            //Apply the patch
            memcpy(hookAddress, patchA, 16);

            //Apply the memcpy
            sceKernelDcacheWritebackAll();
            sceKernelIcacheInvalidateAll();
        }
    }
}

int sceOpenPSIDGetOpenPSID(char *openpsid) {
    memcpy(openpsid, psid, 16);
    return 0;
}

static void handleScreenshot() {
    signed int fd;
    screenTime = 0;
    void *block_addr;
    void *frame_addr;
    int frame_width;
    int pixel_format;
    int sync = 1;
    u32 p;

    while (1) {
        sprintf(buffer, screenPath, screenNo);
        fd = sceIoOpen(buffer, PSP_O_RDONLY, 0777);
        if (fd > 0) {
            sceIoClose(fd);
            screenNo++;
        } else {
            break;
        }
    }

    if ((sceDisplayGetFrameBufferInternal(2, &frame_addr, &frame_width,
            &pixel_format, &sync) < 0) || (frame_addr == NULL)) {
    } else {
        p = (u32) frame_addr;
        if (p & 0x80000000) {
            p |= 0xA0000000;
        } else {
            p |= 0x40000000;
        }

        gamePause(thid);
        bitmapWrite((void *) p, NULL, pixel_format, buffer);
        gameResume(thid);

        screenNo++;
    }
}

unsigned char screenPath[64] = { 0 };
char psid[16];
signed char lolDirection = 1;
unsigned char lolValue = 0;
unsigned char lolInit = 1;
unsigned int screenNo = 0;
unsigned char searchMode = 0;
unsigned char copyMenu = 0; //0=Menu Off, 1=Menu On, Copy selected, 2=Menu On, Paste selected
unsigned int copyData = 0x08804000;
unsigned char screenTime = 0;
unsigned int trackAddress = 0x48804000;
unsigned int trackY = 0;
unsigned int trackX = 0;
unsigned int trackC = 0;
unsigned int trackBackup = 0;
unsigned char trackMode = 0;
unsigned char trackStatus = 0;
unsigned char trackPause = 0;
unsigned int cheatDMA = 0;
unsigned char cheatButtonAgeX = 0;
unsigned char cheatButtonAgeY = 0;
unsigned int browseY = 0;
unsigned int browseC = 0;
unsigned int browseX = 0;
unsigned int browseLines = 16;
unsigned int decodeFormat = 0x48800000;
unsigned int trackFormat = 0x48800000;
unsigned int browseFormat = 0x48800000;
unsigned int decodeAddress = 0x48804000;
unsigned int decodeY = 0;
unsigned int decodeC = 0;
unsigned int decodeX = 0;
unsigned int dumpNo = 0;
unsigned int cheatNo = 0;
unsigned int searchNo = 0;
unsigned int searchMax = 0;
unsigned int searchHistoryCounter = 0;
Block searchHistory[16];
unsigned int searchResultCounter = 0;
unsigned int searchAddress[100];
unsigned int browseAddress = 0x48804000;
unsigned int cheatHz = 0;
unsigned char cheatFlash = 0;
unsigned char cheatPause = 0;
unsigned char cheatSearch = 0;
unsigned char extMenu = 0;
unsigned int extSelected[4] = { 0, 0, 0, 0 };
unsigned char extOpt = 0;
unsigned int extOptArg = 0;
unsigned char cheatSaved = 0;
unsigned int cheatSelected = 0;
unsigned int tabSelected = 0;
unsigned char menuDrawn = 0;
SceCtrlData pad;
unsigned int blockTotal = 0;
unsigned int cheatTotal = 0;
unsigned char buffer[64];

#define BLOCK_MAX 8192
#define CHEAT_MAX 512

#define lineClear(a_line) pspDebugScreenSetXY(0, a_line); pspDebugScreenPuts("                                                                   "); pspDebugScreenSetXY(0, a_line);
#define fileBufferPeek(a_out, a_ahead) if((fileBufferOffset + a_ahead) >= 1024) { fileBufferBackup=sceIoLseek(fd, 0, SEEK_CUR); sceIoLseek(fd, a_ahead, SEEK_CUR); sceIoRead(fd, &a_out, 1); sceIoLseek(fd, fileBufferBackup, SEEK_SET); } else { a_out=fileBuffer[fileBufferOffset + a_ahead]; }
#define fileBufferRead(a_out, a_size) if(fileBufferOffset == 1024) { fileBufferSize=sceIoRead(fd, fileBuffer, 1024); fileBufferOffset=0; } memcpy(a_out, &fileBuffer[fileBufferOffset], a_size); fileBufferOffset+=a_size; fileBufferFileOffset+=a_size;
unsigned int fileBufferSize = 0;
unsigned int fileBufferBackup = 0;
unsigned int fileBufferFileOffset = 0;
unsigned int fileBufferOffset = 1024;

unsigned char* trackModeName[] = { "  0=Instruction BP  ",
        "  1=Data BP         " };
unsigned char* searchModeName[] = {
        "  0=Same                                                        ",
        "  1=Different                                                   ",
        "  2=Greater                                                     ",
        "  3=Less                                                        ",
        "  4=Inc by    ", "  5=Dec by    ", "  6=Equal to  " };
unsigned int decDelta[10] = { 1000000000, 100000000, 10000000, 1000000, 100000,
        10000, 1000, 100, 10, 1 };
